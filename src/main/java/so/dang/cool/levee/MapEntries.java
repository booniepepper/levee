/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package so.dang.cool.levee;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/** Stream helpers for the {@link Map.Entry} class. */
public final class MapEntries {
    private MapEntries() {} // Utility class, no instances needed.

    /**
     * A helper for functions like {@link Stream#filter(Predicate)}.
     */
    public static <K, V> Predicate<Map.Entry<K, V>>
    onKey(Predicate<K> keyPredicate) {
        return entry -> keyPredicate.test(entry.getKey());
    }

    /**
     * A helper for functions like {@link Stream#filter(Predicate)}.
     */
    public static <K, V> Predicate<Map.Entry<K, V>>
    onValue(Predicate<V> valuePredicate) {
        return entry -> valuePredicate.test(entry.getValue());
    }

    /**
     * A helper for functions like {@link Stream#map}.
     */
    public static <K, V> Function<Map.Entry<V, K>, Map.Entry<K, V>>
    invert() {
        return entry -> entryOf(entry.getValue(), entry.getKey());
    }

    /** A helper for functions like {@link Stream#flatMap}. */
    public static <K, V> Function<Map.Entry<V, ? extends Collection<K>>, Stream<Map.Entry<K, V>>>
    invertMany() {
        return entry -> entry.getValue().stream().map(value -> entryOf(value, entry.getKey()));
    }

    /**
     * A helper for functions like {@link Stream#map} or {@link Collectors#mapping}.
     *
     * <p>Equivalent to the
     *
     * <pre>
     * Map.Entry::getKey
     * </pre>
     *
     * method reference, but less verbose.
     */
    public static <K, V> Function<Map.Entry<K, V>, K>
    theKey() {
        return entry -> entry.getKey();
    }

    /**
     * A helper for functions like {@link Stream#map} or {@link Collectors#mapping}.
     *
     * <p>Equivalent to the
     *
     * <pre>
     * Map.Entry::getValue
     * </pre>
     *
     * method reference, but less verbose.
     */
    public static <K, V> Function<Map.Entry<K, V>, V>
    theValue() {
        return entry -> entry.getValue();
    }

    /** A helper for functions like {@link Stream#map} or {@link Collectors#mapping}. */
    public static <K1, K2, V> Function<Map.Entry<K1, V>, Map.Entry<K2, V>>
    keyTo(Function<K1, K2> keyFn) {
        return entry -> entryOf(keyFn.apply(entry.getKey()), entry.getValue());
    }

    /**
     * A helper for functions like {@link Stream#map} or {@link Collectors#mapping}.
     *
     * <p>Transforms only the value of a {@link Map.Entry}.
     */
    public static <K, V1, V2> Function<Map.Entry<K, V1>, Map.Entry<K, V2>>
    valueTo(Function<V1, V2> valueFn) {
        return entry -> entryOf(entry.getKey(), valueFn.apply(entry.getValue()));
    }

    public static <A, K, V> Function<A, Map.Entry<K, V>>
    toEntry(Function<A, K> keyFn, Function<A, V> valueFn) {
        return a -> entryOf(keyFn.apply(a), valueFn.apply(a));
    }

    public static <K, V> Collector<Map.Entry<K, V>, ?, Map<K, V>>
    toMap() {
        return Collectors.toMap(theKey(), theValue());
    }

    public static <K, V> Collector<Map.Entry<K, V>, ?, Map<K, List<V>>>
    toMapOfLists() {
        return Collectors.toMap(
            theKey(),
            e -> {
                var list = new ArrayList();
                list.add(e.getValue());
                return list;
            },
            (l1, l2) -> {
                l1.addAll(l2);
                return l1;
            });
    }

    public static <K, V> Collector<Map.Entry<K, V>, ?, Map<K, Set<V>>>
    toMapOfSets() {
        return Collectors.toMap(
            theKey(),
            e -> {
                var set = new HashSet();
                set.add(e.getValue());
                return set;
            },
            (l1, l2) -> {
                l1.addAll(l2);
                return l1;
            });
    }

    public static <K, V> Map.Entry<K, V>
    entryOf(K key, V value) {
        return new AbstractMap.SimpleImmutableEntry<>(key, value);
    }
}
